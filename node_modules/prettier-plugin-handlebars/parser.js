
const prettier = require('prettier');

// Custom AST node types for Handlebars
const NodeType = {
  DOCUMENT: 'Document',
  TEXT: 'Text',
  EXPRESSION: 'Expression',
  BLOCK: 'Block',
  PARTIAL: 'Partial',
  COMMENT: 'Comment',
  HTML_ELEMENT: 'HTMLElement',
  HTML_TEXT: 'HTMLText'
};

class HandlebarsParser {
  constructor(text, options = {}) {
    this.text = text;
    this.options = options;
    this.pos = 0;
    this.line = 1;
    this.column = 1;
  }

  parse() {
    const children = [];
    
    while (this.pos < this.text.length) {
      const node = this.parseNext();
      if (node) {
        children.push(node);
      }
    }

    return {
      type: NodeType.DOCUMENT,
      children,
      loc: { start: { line: 1, column: 1 }, end: { line: this.line, column: this.column } }
    };
  }

  parseNext() {
    if (this.peek(2) === '{{') {
      return this.parseHandlebarsExpression();
    }
    
    // Check for HTML tags
    if (this.peek() === '<') {
      return this.parseHTMLElement();
    }
    
    return this.parseText();
  }

  parseHandlebarsExpression() {
    const start = { line: this.line, column: this.column };
    
    // Skip opening {{
    this.advance(2);
    
    // Handle comments {{!-- ... --}}
    if (this.peek(3) === '!--') {
      return this.parseComment(start);
    }
    
    // Handle blocks {{#if}}, {{/if}}, etc.
    if (this.peek() === '#' || this.peek() === '/') {
      return this.parseBlock(start);
    }
    
    // Handle partials {{> partial}}
    if (this.peek() === '>') {
      return this.parsePartial(start);
    }
    
    // Regular expression {{helper arg1 arg2}}
    return this.parseExpression(start);
  }

  parseComment(start) {
    this.advance(3); // Skip !--
    
    let content = '';
    while (this.pos < this.text.length - 4) {
      if (this.peek(4) === '--}}') {
        break;
      }
      content += this.advance();
    }
    
    this.advance(4); // Skip --}}
    
    return {
      type: NodeType.COMMENT,
      content: content.trim(),
      loc: { start, end: { line: this.line, column: this.column } }
    };
  }

  parseBlock(start) {
    const isClosing = this.peek() === '/';
    if (isClosing) {
      this.advance(); // Skip /
    } else {
      this.advance(); // Skip #
    }
    
    const helper = this.parseHelper();
    
    // Skip closing }}
    this.skipWhitespace();
    if (this.peek(2) === '}}') {
      this.advance(2);
    }
    
    let children = [];
    let elseNode = null;
    
    if (!isClosing) {
      // Parse block content until we find {{/helper}} or {{else}}
      while (this.pos < this.text.length) {
        if (this.peek(2) === '{{') {
          const nextPos = this.pos + 2;
          if (this.text.substring(nextPos).startsWith('/')) {
            // Check if this is our closing tag
            const tempPos = this.pos;
            this.advance(3); // Skip {{/
            const closingHelper = this.parseIdentifier();
            if (closingHelper === helper.name) {
              this.skipUntil('}}');
              this.advance(2);
              break;
            } else {
              this.pos = tempPos; // Reset position
            }
          } else if (this.text.substring(nextPos).startsWith('else')) {
            // Handle {{else}}
            this.advance(2);
            this.skipWhitespace();
            if (this.peek(4) === 'else') {
              this.advance(4);
              this.skipUntil('}}');
              this.advance(2);
              elseNode = { type: 'ElseBlock', children: [] };
              
              // Parse else content
              while (this.pos < this.text.length) {
                if (this.peek(2) === '{{' && this.text.substring(this.pos + 3).startsWith(helper.name)) {
                  this.advance(3 + helper.name.length);
                  this.skipUntil('}}');
                  this.advance(2);
                  break;
                }
                const node = this.parseNext();
                if (node) elseNode.children.push(node);
              }
              break;
            }
          }
        }
        
        const node = this.parseNext();
        if (node) {
          children.push(node);
        }
      }
    }
    
    return {
      type: NodeType.BLOCK,
      helper,
      children,
      elseNode,
      isClosing,
      loc: { start, end: { line: this.line, column: this.column } }
    };
  }

  parsePartial(start) {
    this.advance(); // Skip >
    this.skipWhitespace();
    
    const name = this.parseStringOrIdentifier();
    const args = this.parseArguments();
    
    this.skipWhitespace();
    if (this.peek(2) === '}}') {
      this.advance(2);
    }
    
    return {
      type: NodeType.PARTIAL,
      name,
      args,
      loc: { start, end: { line: this.line, column: this.column } }
    };
  }

  parseExpression(start) {
    const helper = this.parseHelper();
    
    this.skipWhitespace();
    if (this.peek(2) === '}}') {
      this.advance(2);
    }
    
    return {
      type: NodeType.EXPRESSION,
      helper,
      loc: { start, end: { line: this.line, column: this.column } }
    };
  }

  parseHelper() {
    this.skipWhitespace();
    
    // Handle subexpressions (parentheses)
    if (this.peek() === '(') {
      return this.parseSubExpression();
    }
    
    const name = this.parseIdentifier();
    const args = this.parseArguments();
    
    return { name, args };
  }

  parseSubExpression() {
    this.advance(); // Skip (
    const helper = this.parseHelper();
    this.skipWhitespace();
    if (this.peek() === ')') {
      this.advance();
    }
    return { ...helper, isSubExpression: true };
  }

  parseArguments() {
    const args = [];
    
    while (this.pos < this.text.length && this.peek(2) !== '}}' && this.peek() !== ')') {
      this.skipWhitespace();
      
      if (this.peek(2) === '}}' || this.peek() === ')') break;
      
      // Handle key=value pairs
      const start = this.pos;
      const identifier = this.parseIdentifier();
      
      this.skipWhitespace();
      if (this.peek() === '=') {
        this.advance(); // Skip =
        this.skipWhitespace();
        const value = this.parseStringOrIdentifier();
        args.push({ type: 'NamedArgument', key: identifier, value });
      } else {
        // Reset and parse as positional argument
        this.pos = start;
        const value = this.parseStringOrIdentifier();
        args.push({ type: 'PositionalArgument', value });
      }
    }
    
    return args;
  }

  parseIdentifier() {
    let identifier = '';
    while (this.pos < this.text.length) {
      const char = this.peek();
      if (/[a-zA-Z0-9_\-\.]/.test(char)) {
        identifier += this.advance();
      } else {
        break;
      }
    }
    return identifier;
  }

  parseStringOrIdentifier() {
    this.skipWhitespace();
    
    if (this.peek() === '"' || this.peek() === "'") {
      return this.parseString();
    }
    
    if (this.peek() === '(') {
      return this.parseSubExpression();
    }
    
    return this.parseIdentifier();
  }

  parseString() {
    const quote = this.advance();
    let value = '';
    
    while (this.pos < this.text.length && this.peek() !== quote) {
      if (this.peek() === '\\') {
        this.advance(); // Skip escape
        if (this.pos < this.text.length) {
          value += this.advance();
        }
      } else {
        value += this.advance();
      }
    }
    
    if (this.peek() === quote) {
      this.advance(); // Skip closing quote
    }
    
    return { type: 'String', value };
  }

  parseHTMLElement() {
    const start = { line: this.line, column: this.column };
    
    // Try to parse as HTML using a simple approach
    let content = '';
    let tagDepth = 0;
    
    while (this.pos < this.text.length) {
      const char = this.peek();
      
      if (char === '<') {
        const nextChar = this.peek(1);
        if (nextChar === '/') {
          tagDepth--;
        } else if (nextChar !== '!' && nextChar !== '?') {
          tagDepth++;
        }
        content += this.advance();
      } else if (char === '>' && tagDepth === 1) {
        content += this.advance();
        break;
      } else if (this.peek(2) === '{{') {
        // Stop at Handlebars expression
        break;
      } else {
        content += this.advance();
      }
    }
    
    return {
      type: NodeType.HTML_ELEMENT,
      content,
      loc: { start, end: { line: this.line, column: this.column } }
    };
  }

  parseText() {
    const start = { line: this.line, column: this.column };
    let content = '';
    
    while (this.pos < this.text.length) {
      if (this.peek(2) === '{{' || this.peek() === '<') {
        break;
      }
      content += this.advance();
    }
    
    if (!content) return null;
    
    return {
      type: NodeType.TEXT,
      content,
      loc: { start, end: { line: this.line, column: this.column } }
    };
  }

  peek(offset = 0) {
    const pos = this.pos + offset;
    return pos < this.text.length ? this.text[pos] : '';
  }

  advance(count = 1) {
    let result = '';
    for (let i = 0; i < count && this.pos < this.text.length; i++) {
      const char = this.text[this.pos++];
      result += char;
      if (char === '\n') {
        this.line++;
        this.column = 1;
      } else {
        this.column++;
      }
    }
    return result;
  }

  skipWhitespace() {
    while (this.pos < this.text.length && /\s/.test(this.peek())) {
      this.advance();
    }
  }

  skipUntil(target) {
    while (this.pos < this.text.length && !this.text.substring(this.pos).startsWith(target)) {
      this.advance();
    }
  }
}

function parseHandlebars(text, parsers, options) {
  const parser = new HandlebarsParser(text, options);
  return parser.parse();
}

const parsers = {
  handlebars: {
    parse: parseHandlebars,
    astFormat: 'handlebars-ast',
    locStart: (node) => node.loc.start,
    locEnd: (node) => node.loc.end
  }
};

module.exports = { parsers, NodeType };
